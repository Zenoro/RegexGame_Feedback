{
	"m_DescList":[
		"저희는 일부 기호에 특별한 의미를 부여했습니다. 예를 들어:",
		"<color=#FF68DD>*</color>     이전 정규 표현식을 0번 이상 매칭",
		"<color=#FF68DD>?</color>    이전 요소를 0번 또는 1번 매칭",
		"<color=#3173FF>[]</color>    문자 집합 지정",
		"",
		"그러나 이로 인해 새로운 문제가 발생했습니다.",
		"문자열 \"interesting, <color=#3c3cff>[?*]</color> 123\"의 파란색 부분을 매칭하려면 정규 표현식을 어떻게 작성해야 할까요?",
		"",
		"대부분의 경우, 백슬래시 \"\"를 사용하여 뒤따르는 문자가 원래의 의미를 사용하도록 강제합니다.",
		"<color=#666666>쿼티 키보드 엔터 키 위쪽</color>",
		"",
		"예를 들어, <color=#AB2800>\\[\\?\\*\\]</color>의 매칭 결과는",
		"<color=#666666>interesting,</color> <color=#3c3cff>[?*]</color> <color=#666666>123</color> 입니다.",
		"",
		"<b>일반적인 이스케이프 문자</b>",
		"[ ] ( ) { } . * + ? ^ $ | \\ \" '",
		"이러한 기호는 \\를 사용하여 이스케이프합니다.",
		"예: <color=#AB2800>\\\\</color>를 사용하여 <color=#3c3cff>C:\\Windows\\xxx</color>를 매칭한 결과:",
		"C:<color=#3c3cff>\\</color>Windows\\xxx",
		"C:\\Windows<color=#3c3cff>\\</color>xxx",
		"",
		"<b>미리 정의된 문자 클래스 또는 제어 문자</b>",
		"\\t 탭 문자 \\u0009 매칭",
		"\\n 줄 바꿈 문자 \\u000A 매칭",
		"\\r 캐리지 리턴 문자 \\u000D 매칭",
		"",
		"<b>16진수 표기 이스케이프</b>",
		"\\unnnn 예: \\u0009는 코드 포인트 9에 해당하는 유니코드 문자를 나타냄",
		"\\unnnn 은(는) 보이지 않는 문자, 이모지 및 수학 기호를 강제로 인코딩하는 데 사용할 수 있음",
		"",
		"<b>원시 문자열 리터럴 (Verbatim Strings)</b>",
		"C#에서 다음 두 문자열 선언은 동일합니다.",
		"<color=#3c3cff>string</color> str = <color=#a64444>\"! \" \\' ?\"</color>;",
		"<color=#3c3cff>string</color> str = <color=#a64444>@\"! \"\" ' ?\"</color>;",
		"@로 시작하는 선언 방식은 원시 문자열 리터럴입니다. 원시 문자열 리터럴에서는 \"\"가 \"로 처리되며, 기본 문자열 이스케이프 방식과는 차이가 있습니다.",
		"이 방식은 다른 프로그래밍 언어와는 다소 차이가 있으므로, 통일성을 위해 게임 본체에서는 <b>기본 문자열 이스케이프 방식</b>을 사용하며 원시 문자열 리터럴 방식을 사용하지 않습니다.",
		"",
		"이제 연속된 두 개의 인접 문자를 검사하고자 합니다. 만약 첫 번째 문자가 [ ] ( ) { } . * + ? ^ $ | \\ \" ' 중 하나이고, 두 번째 문자가 위의 특수 문자가 아닌 경우 매칭에 성공합니다.",
		"",
		"100% 입력 데이터에 대해 문제 난이도를 낮추기 위해 다음 규칙을 적용합니다:",
		"1. 모든 기호는 영어 반각 기호입니다.",
		"2. 각 테스트 케이스에는 여러 개의 요구 사항을 충족하는 매칭 결과가 존재할 수 있습니다.",
		"",
		"",
		"오른쪽의 모든 테스트를 통과하는 정규 표현식을 구성해 주세요."
	],
	"m_SystemLanguage":"Korean"
}